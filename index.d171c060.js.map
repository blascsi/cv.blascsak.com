{"mappings":"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","sources":["<anon>","src/js/background.js"],"sourcesContent":["var $51c277a295b661f0$exports = {};\n(function() {\n    const colors = {\n        background: \"#0E0E0E\",\n        circle: \"#141414\"\n    };\n    const circleSizes = {\n        small: 0.05,\n        medium: 0.07,\n        large: 0.1\n    };\n    const circleVelocity = 0.1;\n    const animationController = createAnimationController(document.getElementById(\"background\"), colors, circleSizes, circleVelocity, 0.5);\n    function generateRandom(min, max) {\n        if (min > max) throw new Error(\"Invalid arguments given. Minimum cannot be greater than the maximum.\");\n        if (min === max) return min;\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    }\n    function calculateCircleArea(radius) {\n        return Math.PI * radius ** 2;\n    }\n    function createAnimationController(canvas, colors, sizes, velocity, backgroundFillRatio) {\n        if (backgroundFillRatio > 1 || backgroundFillRatio < 0) throw new Error(\"Background fill ratio should be between 0 and 1\");\n        const ctx = canvas.getContext(\"2d\");\n        let animationFrame;\n        let circles = [];\n        let opacity = 1;\n        function initialzieController() {\n            resizeCanvas();\n            generateBackground();\n        }\n        function generateBackground() {\n            const elements = [];\n            const fillArea = canvas.width * backgroundFillRatio * (canvas.height * backgroundFillRatio);\n            let filledArea = 0;\n            while(filledArea < fillArea)for (let [size, ratio] of Object.entries(sizes)){\n                const circleArea = calculateCircleArea(canvas.width * ratio);\n                if (circleArea + filledArea < fillArea || size === \"small\") {\n                    elements.push(createCircle(canvas.width, canvas.height, canvas.width * ratio, size));\n                    filledArea += circleArea;\n                }\n            }\n            circles = elements;\n        }\n        function fixBackgroundOnResize(maxX, maxY, oldWidth, oldHeight) {\n            if (!circles || !circles.length) return;\n            if (oldWidth && oldHeight) {\n                const widthRatio = maxX / oldWidth;\n                const heightRatio = maxY / oldHeight;\n                circles.forEach((element)=>{\n                    element.x = element.x * widthRatio;\n                    element.y = element.y * heightRatio;\n                });\n            }\n            circles.forEach((element)=>{\n                element.radius = maxX * sizes[element.size];\n            });\n        }\n        function createCircle(maxX, maxY, radius, size) {\n            return {\n                x: generateRandom(radius, maxX - radius),\n                y: generateRandom(radius, maxY - radius),\n                radius: radius,\n                size: size,\n                vx: !!generateRandom(0, 1) ? velocity : -velocity,\n                vy: !!generateRandom(0, 1) ? velocity : -velocity\n            };\n        }\n        function moveBackgroundElements() {\n            for (let circle of circles){\n                if (circle.x + circle.radius >= canvas.width || circle.x - circle.radius <= 0) {\n                    circle.x = circle.x - circle.radius <= 0 ? 0 + circle.radius : canvas.width - circle.radius;\n                    circle.vx = -circle.vx;\n                }\n                if (circle.y + circle.radius >= canvas.height || circle.y - circle.radius <= 0) {\n                    circle.y = circle.y - circle.radius <= 0 ? 0 + circle.radius : canvas.height - circle.radius;\n                    circle.vy = -circle.vy;\n                }\n                circle.x += circle.vx;\n                circle.y += circle.vy;\n                drawCircle(circle, colors.circle);\n            }\n        }\n        function clearCanvas() {\n            ctx.globalCompositeOperation = \"source-over\";\n            ctx.globalAlpha = 1;\n            ctx.fillStyle = colors.background;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n        function resizeCanvas() {\n            const oldWidth = canvas.width;\n            const oldHeight = canvas.height;\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            return fixBackgroundOnResize(window.innerWidth, window.innerHeight, oldWidth, oldHeight);\n        }\n        function shouldUpdate() {\n            return opacity > 0;\n        }\n        function updateOpacity() {\n            const aboveTheFoldAreaVisible = (window.innerHeight - window.scrollY) / window.innerHeight;\n            opacity = aboveTheFoldAreaVisible >= 0 ? aboveTheFoldAreaVisible : 0;\n        }\n        function drawCircle({ x: x, y: y, radius: radius }, color) {\n            ctx.globalCompositeOperation = \"lighter\";\n            ctx.globalAlpha = opacity;\n            ctx.beginPath();\n            ctx.arc(x, y, radius, 0, Math.PI * 2);\n            ctx.closePath();\n            ctx.fillStyle = color;\n            ctx.fill();\n        }\n        function draw() {\n            if (animationFrame) {\n                window.cancelAnimationFrame(animationFrame);\n                animationFrame = null;\n            }\n            // If the animation is not in frame, we should not\n            // calculate new positions, and draw the circles\n            // just clear the canvas and wait for it to be in frame\n            if (!shouldUpdate()) {\n                clearCanvas();\n                animationFrame = window.requestAnimationFrame(draw);\n                return;\n            }\n            clearCanvas();\n            moveBackgroundElements();\n            animationFrame = window.requestAnimationFrame(draw);\n        }\n        function resize() {\n            if (animationFrame) {\n                window.cancelAnimationFrame(animationFrame);\n                animationFrame = null;\n            }\n            resizeCanvas();\n            draw();\n        }\n        return {\n            initialzieController: initialzieController,\n            draw: draw,\n            resize: resize,\n            updateOpacity: updateOpacity\n        };\n    }\n    animationController.initialzieController();\n    window.requestAnimationFrame(animationController.draw);\n    window.addEventListener(\"resize\", animationController.resize);\n    window.addEventListener(\"orientationchange\", animationController.resize);\n    window.addEventListener(\"scroll\", animationController.updateOpacity);\n})();\n\n\n//# sourceMappingURL=index.d171c060.js.map\n","(function () {\n  const colors = {\n    background: '#0E0E0E',\n    circle: '#141414',\n  };\n  const circleSizes = {\n    small: 0.05,\n    medium: 0.07,\n    large: 0.1,\n  };\n  const circleVelocity = 0.1;\n  const animationController = createAnimationController(\n    document.getElementById('background'),\n    colors,\n    circleSizes,\n    circleVelocity,\n    0.5\n  );\n\n  function generateRandom(min, max) {\n    if (min > max)\n      throw new Error(\n        'Invalid arguments given. Minimum cannot be greater than the maximum.'\n      );\n    if (min === max) return min;\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  }\n\n  function calculateCircleArea(radius) {\n    return Math.PI * radius ** 2;\n  }\n\n  function createAnimationController(\n    canvas,\n    colors,\n    sizes,\n    velocity,\n    backgroundFillRatio\n  ) {\n    if (backgroundFillRatio > 1 || backgroundFillRatio < 0)\n      throw new Error('Background fill ratio should be between 0 and 1');\n\n    const ctx = canvas.getContext('2d');\n    let animationFrame;\n    let circles = [];\n    let opacity = 1;\n\n    function initialzieController() {\n      resizeCanvas();\n      generateBackground();\n    }\n\n    function generateBackground() {\n      const elements = [];\n\n      const fillArea =\n        canvas.width *\n        backgroundFillRatio *\n        (canvas.height * backgroundFillRatio);\n      let filledArea = 0;\n\n      while (filledArea < fillArea) {\n        for (let [size, ratio] of Object.entries(sizes)) {\n          const circleArea = calculateCircleArea(canvas.width * ratio);\n          if (circleArea + filledArea < fillArea || size === 'small') {\n            elements.push(\n              createCircle(\n                canvas.width,\n                canvas.height,\n                canvas.width * ratio,\n                size\n              )\n            );\n            filledArea += circleArea;\n          }\n        }\n      }\n\n      circles = elements;\n    }\n\n    function fixBackgroundOnResize(maxX, maxY, oldWidth, oldHeight) {\n      if (!circles || !circles.length) return;\n\n      if (oldWidth && oldHeight) {\n        const widthRatio = maxX / oldWidth;\n        const heightRatio = maxY / oldHeight;\n        circles.forEach((element) => {\n          element.x = element.x * widthRatio;\n          element.y = element.y * heightRatio;\n        });\n      }\n\n      circles.forEach((element) => {\n        element.radius = maxX * sizes[element.size];\n      });\n    }\n\n    function createCircle(maxX, maxY, radius, size) {\n      return {\n        x: generateRandom(radius, maxX - radius),\n        y: generateRandom(radius, maxY - radius),\n        radius,\n        size,\n        vx: !!generateRandom(0, 1) ? velocity : -velocity,\n        vy: !!generateRandom(0, 1) ? velocity : -velocity,\n      };\n    }\n\n    function moveBackgroundElements() {\n      for (let circle of circles) {\n        if (\n          circle.x + circle.radius >= canvas.width ||\n          circle.x - circle.radius <= 0\n        ) {\n          circle.x =\n            circle.x - circle.radius <= 0\n              ? 0 + circle.radius\n              : canvas.width - circle.radius;\n          circle.vx = -circle.vx;\n        }\n        if (\n          circle.y + circle.radius >= canvas.height ||\n          circle.y - circle.radius <= 0\n        ) {\n          circle.y =\n            circle.y - circle.radius <= 0\n              ? 0 + circle.radius\n              : canvas.height - circle.radius;\n          circle.vy = -circle.vy;\n        }\n\n        circle.x += circle.vx;\n        circle.y += circle.vy;\n        drawCircle(circle, colors.circle);\n      }\n    }\n\n    function clearCanvas() {\n      ctx.globalCompositeOperation = 'source-over';\n      ctx.globalAlpha = 1;\n      ctx.fillStyle = colors.background;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    function resizeCanvas() {\n      const oldWidth = canvas.width;\n      const oldHeight = canvas.height;\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n      return fixBackgroundOnResize(\n        window.innerWidth,\n        window.innerHeight,\n        oldWidth,\n        oldHeight\n      );\n    }\n\n    function shouldUpdate() {\n      return opacity > 0;\n    }\n\n    function updateOpacity() {\n      const aboveTheFoldAreaVisible =\n        (window.innerHeight - window.scrollY) / window.innerHeight;\n      opacity = aboveTheFoldAreaVisible >= 0 ? aboveTheFoldAreaVisible : 0;\n    }\n\n    function drawCircle({ x, y, radius }, color) {\n      ctx.globalCompositeOperation = 'lighter';\n      ctx.globalAlpha = opacity;\n      ctx.beginPath();\n      ctx.arc(x, y, radius, 0, Math.PI * 2);\n      ctx.closePath();\n      ctx.fillStyle = color;\n      ctx.fill();\n    }\n\n    function draw() {\n      if (animationFrame) {\n        window.cancelAnimationFrame(animationFrame);\n        animationFrame = null;\n      }\n      // If the animation is not in frame, we should not\n      // calculate new positions, and draw the circles\n      // just clear the canvas and wait for it to be in frame\n      if (!shouldUpdate()) {\n        clearCanvas();\n        animationFrame = window.requestAnimationFrame(draw);\n        return;\n      }\n\n      clearCanvas();\n      moveBackgroundElements();\n      animationFrame = window.requestAnimationFrame(draw);\n    }\n\n    function resize() {\n      if (animationFrame) {\n        window.cancelAnimationFrame(animationFrame);\n        animationFrame = null;\n      }\n\n      resizeCanvas();\n      draw();\n    }\n\n    return {\n      initialzieController,\n      draw,\n      resize,\n      updateOpacity,\n    };\n  }\n\n  animationController.initialzieController();\n  window.requestAnimationFrame(animationController.draw);\n  window.addEventListener('resize', animationController.resize);\n  window.addEventListener('orientationchange', animationController.resize);\n  window.addEventListener('scroll', animationController.updateOpacity);\n})();\n"],"names":["animationController","createAnimationController","canvas","colors","sizes","velocity","backgroundFillRatio","animationFrame","Error","ctx","getContext","circles","opacity","clearCanvas","globalCompositeOperation","globalAlpha","fillStyle","background","fillRect","width","height","resizeCanvas","oldWidth","oldHeight","window","innerWidth","innerHeight","fixBackgroundOnResize","maxX","maxY","length","widthRatio","heightRatio","forEach","element","x","y","radius","size","draw","cancelAnimationFrame","requestAnimationFrame","moveBackgroundElements","circle","vx","vy","drawCircle","color","beginPath","arc","Math","PI","closePath","fill","initialzieController","generateBackground","elements","fillArea","filledArea","ratio","Object","entries","circleArea","push","generateRandom","resize","updateOpacity","aboveTheFoldAreaVisible","scrollY","document","getElementById","small","medium","large","min","max","floor","random","addEventListener"],"version":3,"file":"index.d171c060.js.map"}